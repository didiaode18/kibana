/*
 * Timelion syntax parser
 */

{
 function ltoo (literal) {
  return {type: 'literal', value: literal}
 }

 function simpleLocation (location) {
  return {
   min: location.start.column,
   max: location.end.column
  }
 }

 var functions = [];
 var args = [];
 var variables = {};
}

/*
 expressionList: One or more expressions
*/

start
 = tree:expressionList {
  return {
    tree: tree,
    functions: functions,
    args: args,
    variables: variables
  }
 }

expressionList
 = first:expression rest:(space? ',' space? expression:expression {return expression})* ','? {
   return [first].concat(rest)
 }


/*
 Expression: A chain, either directly or by refernce, or setting a variable
*/

expression
 = variable_set
 / variable_get
 / group
 / chain
 / reference



/*
 Group: Collect multiple chains together to form one
*/

group
 = '(' space? grouped:expressionList space? ')' functions:function* {
  var first = {
    type: 'chainList',
    list: grouped
  }
  first.label = text();

  return {type: "chain", chain: [first].concat(functions)};
 }

/*
 Chain: An expression that retrieves and manipulates data.
 At least one function, with others chained to it.
*/

chain
 = func:function space? rest:function* {return {type: 'chain', chain: [func].concat(rest)}}

/*
 Function: A piece of a chain. Manipulates an object
*/

function_name
 = first:[a-zA-Z]+ rest:[.a-zA-Z0-9_-]* { return first.join('') + rest.join('') }

function "function"
 = space? '.' name:function_name space? '(' space? arg_list:arg_list? space? ')' {
  var result = {
    type: 'function',
    function: name,
    arguments: arg_list || [],
    location: simpleLocation(location()),
    text: text()
  }

  result.arguments.forEach(function (arg) {
   arg.function = name;
   args.push(arg);
  })

  functions.push(result)
  return result;
 }
 / '.' func:function_name? {
  var exception = {
   type: 'incompleteFunction',
   function: func,
   location: simpleLocation(location()),
   text: text()
  }
  error(JSON.stringify(exception));
 }


/*
 Argument: A parameter used to configure a function. Ordered, or named.
*/

arg_list
 = first:argument rest:(space? ',' space? arg:argument {return arg})* ','? {
  return [first].concat(rest);
 }

argument
 = name:function_name space? '=' space? value:arg_type {
  return {
   type: 'namedArg',
   name: name,
   value: value,
   location: simpleLocation(location()),
   text: text()
  }
 }
 / element:arg_type {return element}

arg_type
 = variable_get
 / reference
 / group
 / chain
 / literal:literal {
  var result = ltoo(literal);
  result.location = simpleLocation(location()),
  result.text = text();
  return result;
 }

/*
 Reference: Get the entire contents, or just one series
*/

reference
 = '@' plot:integer ':' series:integer {
  return {
   type: 'reference',
   plot: plot,
   series: series
  }
 }
 / '@' plot:integer {
  return {
   type: 'reference',
   plot: plot
  }
 }

/*
 Variable: A way to make reusable arguments
*/

variable_get
 = '$' name:function_name {
  if (variables[name]) {
   return variables[name];
  } else {
   error('$' + name + ' is not defined')
  }
 }

variable_set
 = '$' name:function_name space? '=' space? value:arg_type {
  variables[name] = value;
 }

/*
 Core types: Your basic literals.
*/

literal "literal"
  =  '"' chars:dq_char* '"' { return chars.join(''); } // double quoted string
  / "'" chars:sq_char* "'" { return chars.join(''); } // single quoted string
  / 'true'  { return true; } // unquoted literals from here down
  / 'false' { return false; }
  / 'null'  { return null; }
  / string:[^()"',=\ \t]+ { // this also matches numbers via Number()
   var result = string.join('');
   // Sort of hacky, but PEG doesn't have backtracking so
   // a number rule is hard to read, and performs worse
   if (isNaN(Number(result))) return result;
   return Number(result)
  }

space
 = [\ \t\r\n]+

dq_char
  = "\\" sequence:('"' / "\\") { return sequence; }
  / [^"] // everything except "

sq_char
  = "\\" sequence:("'" / "\\") { return sequence; }
  / [^'] // everything except '

integer
 = digits:[0-9]+ {return parseInt(digits.join(''))}
